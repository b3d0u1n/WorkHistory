<hr>
<!--<h4 class="sub-project first-color">-->
<h4 class="sub-project fourth-color">
	Gitlab Build/Deploy Standardization
</h4>

<!-- Dates: 2018 - 2022
</br>Role: Lead -->
	
<!--  -->

<!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Objectives</i>
</h5>

<div class="sub-project-detail">
	<p>Unify build and deploy for all internal and customer facing systems.  </p>
</div><!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Responsibilites</i>
</h5>

<div class="sub-project-detail">
	<p>I was responsible deploying and maintaining a gitlab runner architecture.  I was tasked with unifying all builds and deployments with versioned build/deploy pipelines.  I migrated engineering teams workflows to use the new system.</p>
</div><!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Key Challenges</i>
</h5>

<div class="sub-project-detail">
	<p>At the start of the project the following approaches were being used:</p>
	<ul><li>	Running Ansible from a local laptop with uncommitted playbooks</li>
	<li>	Checking code out directly to deployed AMI’s and building in production </li>
	<li>	Updating production AMI dependencies by hand </li>
	<li>	Deploying docker containers via AWS ECR</li>
	<li>	Developing code on Vagrant images </li>
	<li>	Applying uncommitted terraform by hand</li></ul>
<p>This set the following obligations:</p>
	<ul><li>	Support building docker, vagrant and AMI images</li>
	<li>	Centralize terraform code and guard against concurrent apply operations</li>
	<li>	Collect all local automation and manual processes, translate them into Gitlab CI</li>
	<li>	Get sign-off from all engineering groups </li></ul>

</div><!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Technical Details</i>
</h5>

<div class="sub-project-detail">
	<p>A Build testing, promotion and deployment sequence was developed and defined in Gitlab CI.  This approach was implemented and tested with an internal anchor client.  Once this working the schematic and implemented internal solution were provided as a reference to other teams.</p>
<center>
<p>
<img src="Gitlab_Build_Deploy_Stan/Technical_Details.jpg" alt="" >
</p>

</center>

<p>The initial standardization goal was to have all existing builds and deployments in the company running with pipeline definitions that were in source control.  Further work on unifying builds followed subsequently.</p>

</div><!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Project Deliverables</i>
</h5>

<div class="sub-project-detail">
	<p>All builds were unified on this system.  Developer environments were moved off of Vagrant and onto Docker.  All builds were containerized; custom AMI’s were fully deprecated.  A common deployment workflow for all containerized systems was established.</p>
</div><!--<h5 class="sub-project-item second-color">-->
<h5 class="sub-project-item fifth-color">
		<i>Current State</i>
</h5>

<div class="sub-project-detail">
	<p>With the help of this system, the company migrated all deployments to docker containers.  Once this was an achieved deployments were fully standardized across the frontend, research, data and infrastructure teams.  The gitlab runner architecture was decommissioned.</p>
</div>
