<h4 class="project-item third-color">
	<i>Technical Details</i>
</h4>

<div class="project-item-detail">
	<p><b><u>Data Migration</p>
</u></b><p>The data for users was encrypted with triple DES in a proprietary no-sql data store.  This was a blob store and individual transaction records were byte-delimited with a non-printable control character.  Each user’s history was encrypted with a unique encryption key.  Migration from the old to new systems was implemented so that a user’s data was migrated to MySql when they accessed their history.  Records were written to the new system using AES encryption which was the standard required by the Yahoo! Security Team ( a.k.a. Paranoids ).  Referential integrity was not leveraged in the database engine.  MyISAM tables were used as they were better understood, and had been used in production by other properties in the company.</p>
<p>A final pass was made through the full user set - using batch processing to ensure that history was fully migrated.  Batch processing was able to access user encryption keys for in-memory processing.  ( I don’t recall the full details of how this part of the mechanism worked. )</p><b><u></p>

<p>Transaction History Management</u></b></p>

<p>Transaction history was stored with an unbounded history window.  Transaction data was encrypted with a DES/3DES symmetric-key block cipher.</p>
<p>Identifying the first and last records of the merge window in the new history and the existing history needed take into account the possible changes in all three fields.  This was achieved using a sequence of rules that would be tested in decreasing order of strictness.</p>
<p><b>The Algorithm:</b></p>
	<ul><li>	Take the last record of the new data set and identify its entry in the history.</li>
	<li>	Find the lower bound of the new transaction set in the historical record</li></ul>
	<blockquote>⁃	equal match of all three fields</blockquote>
	<blockquote>⁃	equal date, equal description, different amount</blockquote>
	<blockquote>⁃	equal date, different description, equal amount</blockquote>
	<blockquote>⁃	equal date, different description, different amount ( no other entries with the same date )</blockquote>
	<blockquote>⁃	newer date, equal description, equal amount</blockquote>
	<blockquote>⁃	newer date, different description, equal amount</blockquote>
	<blockquote>⁃	newer date, equal description, different amount</blockquote>
	<blockquote>⁃	newer date, different description, different amount</blockquote>
	<blockquote>⁃	missing date in existing history range</blockquote>
	<ul><li>	Find the upper bound of the new transaction set already stored in the historical record</li></ul>
	<blockquote>⁃	Take the newest historical transaction record(s) according to date</blockquote>
	<blockquote>⁃	Use the ruleset as listed above</blockquote>
	<ul><li>	Mege the received merge set with the historical merge set</li></ul>
	<blockquote>⁃	if the cardinality of the two sets is equal</blockquote>
	<blockquote>⁃	follow the rules as above</blockquote>
	<blockquote>⁃	if the received set has a higher cardinality identify new records and add them</blockquote>
	<blockquote>⁃	follow the rules as above to isolate the new records and add</blockquote>
	<blockquote>⁃	if the received set has a lower cardinality identify deleted records and remove them</blockquote>
	<blockquote>⁃	follow the rules as above and isolate old records that should be removed</blockquote>
<p>There were further heuristics identified in practice that were added to the end of the basic rule set, eventually amounting to close to 40.  </p>
<p>The rules were implemented as functors and could be combined to form rule chains at compile time using the Loki library.  In order to develop refinements a test harness was developed that could run a ‘dry run; merge using two differently configured rule chains, this provided a way to verify if a newer ruleset improved results for edge cases as they were identified in processing or reported by a specific customer.  </p>
<p>The additional challenge was that historical records were encrypted on a per-user basis and new histories could only be processed within the security context of a given user’s credential set.</p>
</div>